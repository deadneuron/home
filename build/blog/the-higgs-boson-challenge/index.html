<!DOCTYPE html><html><head><title>Blog | The White Acre</title><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="icon" href="/static/favicon.ico" /><link rel="stylesheet" href="/static/article.css" /><link rel="preconnect" href="https://fonts.googleapis.com" /><link rel="preconnect" href="https://fonts.gstatic.com" /><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@500;700&amp;display=block" /><link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.css" /><script src="https://api.mapbox.com/mapbox-gl-js/v2.1.1/mapbox-gl.js"></script></head><body><div class="home"><header><div class="wrapper"><a href="/" class="logo"><img src="/static/logo.svg" /></a><nav><a href="/about">About</a><a href="/blog">Blog</a><a href="/models">Models</a><a href="/research">Research</a></nav></div></header><main><div class="hero" style="background-image: url(/static/trees-bg.png)"><div class="overlay"></div><div class="wrapper"><h1>The Higgs Boson Challenge</h1><p>Hello world</p></div></div><div class="wrapper"><p>In 2012, the ATLAS experiment at the Large Hadron Collider in Switzerland, discovered a new particle called the Higgs Boson. This discovery was a breakthrough in particle physics, as the Higgs Boson was long theorized to exist, but almost impossible to detect. It's small, has no spin or electrical charge, and is so unstable that it decays into other particles almost instantly.[<sup>1</sup>] After the discovery, the media dubbed the Higgs Boson &quot;the god particle&quot; due to its role in generating mass as other particles interact with the Higgs field.</p>
<p>## Introduction</p>
<p>The Large Hadron Collider is a machine that collides protons together at high speed. When they collide, they produce a small explosion and the LHC measures and tracks the resulting particles.</p>
<p>Through this process, the higgs boson may or may not appear. It decays so fast that the LHC can not observe it directly. By looking at the final state of the particles, we can perform a kind of backtracking and deduce if the particles were the result of a higgs boson decay.</p>
<p>In this dataset, every row corresponds to a collision event. Every event contains one lepton, one hadronic tau, and a variable number of jets. We're given the measured momenta of these particles and using these values and some special features derived by the physicists at the LHC, we are going to try to detect whether an event contained a higgs boson or not.</p>
<p>## Overview</p>
<p>The training and testing datasets come from <a href="https://www.kaggle.com/c/higgs-boson/data" class="uri">https://www.kaggle.com/c/higgs-boson/data</a>. They contain 250,000 and 550,000 instances respectively. Each feature of each event starts with either PRI or DER, standing for primitive or derived. The primitive features are raw measurements obtained directly from the collision and derived features are attributes computed from that primitive data.</p>
<p>The folks at ATLAS have provided a great rundown of particle physics for non physicists here <a href="http://opendata.cern.ch/record/329" class="uri">http://opendata.cern.ch/record/329</a>.</p>
<p>```julia using CSV, DataFrames, Gadfly</p>
<p>train = CSV.read(&quot;train.csv&quot;) ```</p>
<p>```julia <span class="citation">@show</span> describe(train) ```</p>
<p>```text │ Row │ variable │ mean │ min │ median │ max │ nunique │ nmissing │ eltype │ │ │ Symbol │ Union… │ Any │ Union… │ Any │ Union… │ Nothing │ DataType │ ├─────┼─────────────────────────────┼─────────────┼────────────┼─────────┼─────────┼─────────┼──────────┼──────────┤ │ 1 │ EventId │ 2.25e5 │ 100000 │ 2.25e5 │ 349999 │ │ │ Int64 │ │ 2 │ DER<sub>massMMC</sub> │ -49.0231 │ -999.0 │ 105.012 │ 1192.03 │ │ │ Float64 │ │ 3 │ DER<sub>masstransversemetlep</sub> │ 49.2398 │ 0.0 │ 46.524 │ 690.075 │ │ │ Float64 │ │ 4 │ DER<sub>massvis</sub> │ 81.182 │ 6.329 │ 73.752 │ 1349.35 │ │ │ Float64 │ │ 5 │ DER<sub>pth</sub> │ 57.896 │ 0.0 │ 38.4675 │ 2835.0 │ │ │ Float64 │ │ 6 │ DER<sub>deltaetajetjet</sub> │ -708.421 │ -999.0 │ -999.0 │ 8.503 │ │ │ Float64 │ │ 7 │ DER<sub>massjetjet</sub> │ -601.237 │ -999.0 │ -999.0 │ 4974.98 │ │ │ Float64 │ │ 8 │ DER<sub>prodetajetjet</sub> │ -709.357 │ -999.0 │ -999.0 │ 16.69 │ │ │ Float64 │ │ 9 │ DER<sub>deltartaulep</sub> │ 2.3731 │ 0.208 │ 2.4915 │ 5.684 │ │ │ Float64 │ │ 10 │ DER<sub>pttot</sub> │ 18.9173 │ 0.0 │ 12.3155 │ 2835.0 │ │ │ Float64 │ │ 11 │ DER<sub>sumpt</sub> │ 158.432 │ 46.104 │ 120.665 │ 1852.46 │ │ │ Float64 │ │ 12 │ DER<sub>ptratioleptau</sub> │ 1.43761 │ 0.047 │ 1.28 │ 19.773 │ │ │ Float64 │ │ 13 │ DER<sub>metphicentrality</sub> │ -0.128305 │ -1.414 │ -0.356 │ 1.414 │ │ │ Float64 │ │ 14 │ DER<sub>lepetacentrality</sub> │ -708.985 │ -999.0 │ -999.0 │ 1.0 │ │ │ Float64 │ │ 15 │ PRI<sub>taupt</sub> │ 38.7074 │ 20.0 │ 31.804 │ 764.408 │ │ │ Float64 │ │ 16 │ PRI<sub>taueta</sub> │ -0.010973 │ -2.499 │ -0.023 │ 2.497 │ │ │ Float64 │ │ 17 │ PRI<sub>tauphi</sub> │ -0.00817107 │ -3.142 │ -0.033 │ 3.142 │ │ │ Float64 │ │ 18 │ PRI<sub>leppt</sub> │ 46.6602 │ 26.0 │ 40.516 │ 560.271 │ │ │ Float64 │ │ 19 │ PRI<sub>lepeta</sub> │ -0.0195075 │ -2.505 │ -0.045 │ 2.503 │ │ │ Float64 │ │ 20 │ PRI<sub>lepphi</sub> │ 0.043543 │ -3.142 │ 0.086 │ 3.142 │ │ │ Float64 │ │ 21 │ PRI<sub>met</sub> │ 41.7172 │ 0.109 │ 34.802 │ 2842.62 │ │ │ Float64 │ │ 22 │ PRI<sub>metphi</sub> │ -0.0101192 │ -3.142 │ -0.024 │ 3.142 │ │ │ Float64 │ │ 23 │ PRI<sub>metsumet</sub> │ 209.797 │ 13.678 │ 179.739 │ 2003.98 │ │ │ Float64 │ │ 24 │ PRI<sub>jetnum</sub> │ 0.979176 │ 0 │ 1.0 │ 3 │ │ │ Int64 │ │ 25 │ PRI<sub>jetleadingpt</sub> │ -348.33 │ -999.0 │ 38.96 │ 1120.57 │ │ │ Float64 │ │ 26 │ PRI<sub>jetleadingeta</sub> │ -399.254 │ -999.0 │ -1.872 │ 4.499 │ │ │ Float64 │ │ 27 │ PRI<sub>jetleadingphi</sub> │ -399.26 │ -999.0 │ -2.093 │ 3.141 │ │ │ Float64 │ │ 28 │ PRI<sub>jetsubleadingpt</sub> │ -692.381 │ -999.0 │ -999.0 │ 721.456 │ │ │ Float64 │ │ 29 │ PRI<sub>jetsubleadingeta</sub> │ -709.122 │ -999.0 │ -999.0 │ 4.5 │ │ │ Float64 │ │ 30 │ PRI<sub>jetsubleadingphi</sub> │ -709.119 │ -999.0 │ -999.0 │ 3.142 │ │ │ Float64 │ │ 31 │ PRI<sub>jetallpt</sub> │ 73.0646 │ -0.0 │ 40.5125 │ 1633.43 │ │ │ Float64 │ │ 32 │ Weight │ 1.64677 │ 0.00150187 │ 1.15619 │ 7.82254 │ │ │ Float64 │ │ 33 │ Label │ │ b │ │ s │ 2 │ │ String │ ```</p>
<p>The &quot;-999.0&quot; values scattered throughout the dataset represent missing or meaningless fields. To ease data exploration, we're creating a working dataframe with the columns containing missing data removed.</p>
<p>```julia</p>
<p>missingcols = [ :EventId, :DER<sub>massMMC</sub>, :DER<sub>deltaetajetjet</sub>, :DER<sub>massjetjet</sub>, :DER<sub>prodetajetjet</sub>, :DER<sub>lepetacentrality</sub>, :PRI<sub>jetleadingpt</sub>, :PRI<sub>jetleadingeta</sub>, :PRI<sub>jetleadingphi</sub>, :PRI<sub>jetsubleadingpt</sub>, :PRI<sub>jetsubleadingeta</sub>, :PRI<sub>jetsubleadingphi</sub> ]</p>
<p>working = deletecols(train, missingcols) ```</p>
<p>### Event Distribution</p>
<p>Each event in the training set contains a label that tells us whether the event contained a higgs boson or not. By splitting up our working set into groups based on the label, we can look at the distributions and patterns of the features in those groups.</p>
<p>```julia signal, background = groupby(working, :Label) ```</p>
<p>```text First Group (85667 rows): Label = &quot;s&quot;. Omitted printing of 27 columns │ Row │ EventId │ DER<sub>massMMC</sub> │ DER<sub>masstransversemetlep</sub> │ DER<sub>massvis</sub> │ DER<sub>pth</sub> │ DER<sub>deltaetajetjet</sub> │ │ │ Int64 │ Float64⍰ │ Float64 │ Float64 │ Float64 │ Float64⍰ │ ├───────┼─────────┼──────────────┼─────────────────────────────┼──────────────┼──────────┼──────────────────────┤ │ 1 │ 100000 │ 138.47 │ 51.655 │ 97.827 │ 27.98 │ 0.91 │ │ 2 │ 100006 │ 148.754 │ 28.862 │ 107.782 │ 106.13 │ 0.733 │ ⋮ │ 85665 │ 349991 │ 133.457 │ 77.54 │ 88.989 │ 69.65 │ missing │ │ 85666 │ 349993 │ 130.075 │ 3.918 │ 66.781 │ 77.369 │ 0.936 │ │ 85667 │ 349997 │ 105.457 │ 60.526 │ 75.839 │ 39.757 │ missing │ ⋮ Last Group (164333 rows): Label = &quot;b&quot;. Omitted printing of 27 columns │ Row │ EventId │ DER<sub>massMMC</sub> │ DER<sub>masstransversemetlep</sub> │ DER<sub>massvis</sub> │ DER<sub>pth</sub> │ DER<sub>deltaetajetjet</sub> │ │ │ Int64 │ Float64⍰ │ Float64 │ Float64 │ Float64 │ Float64⍰ │ ├────────┼─────────┼──────────────┼─────────────────────────────┼──────────────┼──────────┼──────────────────────┤ │ 1 │ 100001 │ 160.937 │ 68.768 │ 103.235 │ 48.146 │ missing │ │ 2 │ 100002 │ missing │ 162.172 │ 125.953 │ 35.635 │ missing │ ⋮ │ 164331 │ 349996 │ missing │ 58.179 │ 68.083 │ 22.439 │ missing │ │ 164332 │ 349998 │ 94.951 │ 19.362 │ 68.812 │ 13.504 │ missing │ │ 164333 │ 349999 │ missing │ 72.756 │ 70.831 │ 7.479 │ missing │ ```</p>
<p>The ratio of signal to background events in the training set is about 1:2. The distributions of the features are pretty much the same except for the transverse momentum features. My hunch is that these fields will end up being important in a machine learning model.</p>
<p>&lt;object data=&quot;sb-stats.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;param name=&quot;url&quot; value=&quot;sb-stats.svg&quot;&gt; &lt;/object&gt;</p>
<p>```julia</p>
<p>function boxplot<sub>stats</sub>(a) q1 = quantile(a, 0.25) q2 = quantile(a, 0.5) q3 = quantile(a, 0.75)</p>
<p>lf = q1 - (1.5 * (q3 - q1)) uf = q3 + (1.5 * (q3 - q1))</p>
<p>return (lf, q1, q2, q3, uf) end</p>
<p>sb<sub>stats</sub> = DataFrame(name=[], label=[], lf=[], lh=[], m=[], uh=[], uf=[])</p>
<p>for i in 1:20 stats = boxplot<sub>stats</sub>(signal[:, i]) push!(sb<sub>stats</sub>, [names(signal)[i], &quot;s&quot;, stats...])</p>
<p>stats = boxplot<sub>stats</sub>(background[:, i]) push!(sb<sub>stats</sub>, [names(background)[i], &quot;b&quot;, stats...]) end ```</p>
<p>### Particle Distribution</p>
<p>The ATLAS detector at the LHC is the largest particle detector in the world. It measures the 3 dimensional final state properties of the collision through a series of concentric cylinders around the collision point.[<sup>6</sup>] Here's a plot of each hadronic tau and lepton for every event in the training set.</p>
<p>&lt;video controls&gt; &lt;source src=&quot;particles-3d.mp4&quot; type=&quot;video/mp4&quot;&gt; Video not supported. &lt;/video&gt;</p>
<p>```julia using Makie</p>
<p>tau<sub>coordinates</sub> = Point3f0[] lep<sub>coordinates</sub> = Point3f0[]</p>
<p>function cartesian(pt, ϕ, η) x = pt * cos(ϕ) y = pt * sin(ϕ) z = pt * sinh(η)</p>
<p>return (x, y, z) end</p>
<p>for row in eachrow(train) push!(tau<sub>coordinates</sub>, cartesian(row[:PRI<sub>taupt</sub>], row[:PRI<sub>tauphi</sub>], row[:PRI<sub>taueta</sub>])) push!(lep<sub>coordinates</sub>, cartesian(row[:PRI<sub>leppt</sub>], row[:PRI<sub>lepphi</sub>], row[:PRI<sub>lepeta</sub>])) end</p>
<p>scene = Scene(resolution=(1200, 800), backgroundcolor=&quot;#222831&quot;) scatter!(scene, tau<sub>coordinates</sub>, markersize=5, color=&quot;#fe4365&quot;) scatter!(scene, lep<sub>coordinates</sub>, markersize=5, color=&quot;#eca25c&quot;)</p>
<p>scale!(scene, 2, 2, 2) scene.center = false</p>
<p>record(scene, &quot;particles-3d.mp4&quot;, 1:200) do i rotate<sub>cam</sub>!(scene, 0.01, 0.0, 0.0) end</p>
<p>```</p>
<p>This density plot shows the distribution of those particles in the transverse plane. Anything that escapes down the longitudinal axis is not detectable, and thus we see most particles end up in a small ring around the z-axis.</p>
<p>&lt;object data=&quot;coordinate-density.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;param name=&quot;url&quot; value=&quot;coordinate-density.svg&quot;&gt; &lt;/object&gt;</p>
<p>```julia coordinates = DataFrame(x=[], y=[], z=[])</p>
<p>for row in eachrow(working) push!(coordinates, cartesian(row[:PRI<sub>taupt</sub>], row[:PRI<sub>tauphi</sub>], row[:PRI<sub>taueta</sub>])) push!(coordinates, cartesian(row[:PRI<sub>leppt</sub>], row[:PRI<sub>lepphi</sub>], row[:PRI<sub>lepeta</sub>])) end</p>
<p>plot( coordinates, x = :x, y = :y, Geom.density2d, Scale.color<sub>continuous</sub>(colormap=x-&gt;get(ColorSchemes.blackbody, x)) ) ```</p>
<p>### What role do jets play?</p>
<p>A jet is a narrow stream of particles that occur as the result of the hadronization of a quark or gluon.[<sup>7</sup>] Every event in our dataset has either 0, 1, 2, or 3+ jets. These jets are important as they give us crucial insight into the energy of the system. In our training set, events with two jets show the highest probability to contain a higgs boson.</p>
<p>&lt;object data=&quot;num-jets.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;param name=&quot;url&quot; value=&quot;num-jets.svg&quot;&gt; &lt;/object&gt;</p>
<p>```julia jet<sub>groups</sub> = groupby(working, :PRI<sub>jetnum</sub>, sort=true) jet<sub>df</sub> = DataFrame(num<sub>jets</sub>=[], num<sub>s</sub>=[], num<sub>b</sub>=[])</p>
<p>for group in jet<sub>groups</sub> num<sub>jets</sub> = first(group[:PRI<sub>jetnum</sub>]) num<sub>s</sub> = count(group[:Label] .== &quot;s&quot;) num<sub>b</sub> = count(group[:Label] .== &quot;b&quot;)</p>
<p>push!(jet<sub>df</sub>, (num<sub>jets</sub>, num<sub>s</sub>, num<sub>b</sub>))</p>
<p>println(&quot;$num<sub>jets</sub>: $(num<sub>s</sub> / num<sub>b</sub>)&quot;)</p>
<p>end</p>
<p>plot( stack(jet<sub>df</sub>, [:num<sub>s</sub>, :num<sub>b</sub>]), x = :num<sub>jets</sub>, y = :value, color = :variable, Geom.bar(position = :dodge) ) ```</p>
<p>### Missing Mass and Energy</p>
<p>Energy in the ATLAS detector can escape detection. The two primary ways this happens is through the neutrino, a small fundamental particle that doesn't strongly interact with matter, and through the longitudinal axis, where the machine doesn't have detection capabilities. Using the law of the conservation of momentum, physicists can infer properties of the missing energy and use that to estimate the candidate mass of a Higgs Boson in any given event.</p>
<p>&lt;object data=&quot;transverse-energy.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;param name=&quot;url&quot; value=&quot;transverse-energy.svg&quot;&gt; &lt;/object&gt;</p>
<p>&lt;object data=&quot;higgs-invariant-mass.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;param name=&quot;url&quot; value=&quot;higgs-invariant-mass.svg&quot;&gt; &lt;/object&gt;</p>
<p>### Correlations</p>
<p>The features that are most correlated to each other are the tau phi, tau eta, lepton phi and lepton eta angles, as well as a couple of derived features that depend on those. Due to the missing values, we removed most of the jet features, which are probably strongly correlated with the related jet derived features.</p>
<p>&lt;object data=&quot;correlations.svg&quot; type=&quot;image/svg+xml&quot;&gt; &lt;param name=&quot;url&quot; value=&quot;correlations.svg&quot;&gt; &lt;/object&gt;</p>
<p>```julia correlations = cor(Matrix(working[:, 1:20]))</p>
<p>spy( correlations, Scale.y<sub>discrete</sub>(labels=i-&gt;names(working[:, 1:20])[i]), Guide.ylabel(nothing), Guide.colorkey(title=&quot;Correlation &quot;), Guide.xticks(label=false), Guide.xlabel(nothing) ) ```</p>
<p>## Building The Model</p>
<p>The goal of this project is to classify events into signal or background. Using our exploration as a guide, we're going to build a model that will give us the probability that a given event produced a Higgs Boson.</p>
<p>### Evaluation Metric</p>
<p>The evaluation metric given to us by ATLAS is the approximate median significance. The AMS is a loss function that looks to reduce our false discovery rate. The goal for our model is to estimate with a high confidence that any predicted signal event is in fact a signal.</p>
<p><span class="math display">\displaystyle 
AMS = \sqrt{2\left((s+b+b_r) \log \left(1 + \frac{s}{b + b_r}\right)-s\right)}
</span></p>
<p><span class="math display">\displaystyle 
s = true\ positive\ rate\\
b = false\ positive\ rate\\
b_r = 10
</span></p>
<p>### Preparing the Data</p>
<p>We're loading our data here and splitting it into subsets of features, labels, and weights.</p>
<p>```julia using CSV, DataFrames, Statistics, XGBoost</p>
<p>train = CSV.read(&quot;higgs-boson/train.csv&quot;) test = CSV.read(&quot;higgs-boson/test.csv&quot;) ```</p>
<p>### Feature Selection and Engineering</p>
<p>I came across a bunch of ideas for feature engineering after reading some post competition blog posts. Some people used transformations and combinations to get models trained on upwards of 700 features. Some people got great results on models trained without any extra features at all.</p>
<p>The first place finisher, Gabor Melis used 10 extra features. 5 based on the open angles between particles and 5 based around mass.[<sup>8</sup>] For our model, I'm going to keep it simple and add the open angle features. Due to the rotational symmetry around the z-axis, we can drop the raw phi features after adding our open angle features.</p>
<p>```julia</p>
<p>delta<sub>phi</sub>(ϕ1, ϕ2) = (ϕ1 == -999 || ϕ2 == -999) ? -999.0 : abs(ϕ1 - ϕ2)</p>
<p>train[:ALGO<sub>deltaphitaulep</sub>] = delta<sub>phi</sub>.(train[:PRI<sub>tauphi</sub>], train[:PRI<sub>lepphi</sub>]) train[:ALGO<sub>deltaphitaujet1</sub>] = delta<sub>phi</sub>.(train[:PRI<sub>tauphi</sub>], train[:PRI<sub>jetleadingphi</sub>]) train[:ALGO<sub>deltaphitaujet2</sub>] = delta<sub>phi</sub>.(train[:PRI<sub>tauphi</sub>], train[:PRI<sub>jetsubleadingphi</sub>]) train[:ALGO<sub>deltaphilepjet1</sub>] = delta<sub>phi</sub>.(train[:PRI<sub>lepphi</sub>], train[:PRI<sub>jetleadingphi</sub>]) train[:ALGO<sub>deltaphilepjet2</sub>] = delta<sub>phi</sub>.(train[:PRI<sub>lepphi</sub>], train[:PRI<sub>jetsubleadingphi</sub>]) train[:ALGO<sub>deltaphijet1jet2</sub>] = delta<sub>phi</sub>.(train[:PRI<sub>jetleadingphi</sub>], train[:PRI<sub>jetsubleadingphi</sub>])</p>
<p>test[:ALGO<sub>deltaphitaulep</sub>] = delta<sub>phi</sub>.(test[:PRI<sub>tauphi</sub>], test[:PRI<sub>lepphi</sub>]) test[:ALGO<sub>deltaphitaujet1</sub>] = delta<sub>phi</sub>.(test[:PRI<sub>tauphi</sub>], test[:PRI<sub>jetleadingphi</sub>]) test[:ALGO<sub>deltaphitaujet2</sub>] = delta<sub>phi</sub>.(test[:PRI<sub>tauphi</sub>], test[:PRI<sub>jetsubleadingphi</sub>]) test[:ALGO<sub>deltaphilepjet1</sub>] = delta<sub>phi</sub>.(test[:PRI<sub>lepphi</sub>], test[:PRI<sub>jetleadingphi</sub>]) test[:ALGO<sub>deltaphilepjet2</sub>] = delta<sub>phi</sub>.(test[:PRI<sub>lepphi</sub>], test[:PRI<sub>jetsubleadingphi</sub>]) test[:ALGO<sub>deltaphijet1jet2</sub>] = delta<sub>phi</sub>.(test[:PRI<sub>jetleadingphi</sub>], test[:PRI<sub>jetsubleadingphi</sub>])</p>
<p>train = deletecols(train, [:PRI<sub>tauphi</sub>, :PRI<sub>lepphi</sub>, :PRI<sub>metphi</sub>, :PRI<sub>jetleadingphi</sub>, :PRI<sub>jetsubleadingphi</sub>]) test = deletecols(test, [:PRI<sub>tauphi</sub>, :PRI<sub>lepphi</sub>, :PRI<sub>metphi</sub>, :PRI<sub>jetleadingphi</sub>, :PRI<sub>jetsubleadingphi</sub>]) ```</p>
<p>### Training</p>
<p>The most popular and powerful models in machine learning competitions are ensembles of neural networks or gradient boosting trees. Neural networks tend to do great when the input data is complex or irregular, like images or language, and gradient boosting trees work well with organized and tabular data.</p>
<p>XGBoost is a popular implementation of gradient boosting trees which I found to be fast, easy to use and memory efficient. We'll use XGBoost for this article, and in less than 20 lines of code, we can train a model that is capable of being compeitive on the leaderboard. The documetation, <a href="https://xgboost.readthedocs.io/en/latest/" class="uri">https://xgboost.readthedocs.io/en/latest/</a>, is helpful if you want to learn more about gradient boosting and what goes in to tuning the model.</p>
<p>```julia train<sub>w</sub> = convert(Vector, train[:Weight]) train<sub>x</sub> = convert(Matrix, deletecols(train, [:EventId, :Weight, :Label])) train<sub>y</sub> = convert(Vector, map(i -&gt; i == &quot;s&quot; ? 1 : 0, train[:Label]))</p>
<p>dtrain = DMatrix(train<sub>x</sub>, false, -999.0, weight=train<sub>w</sub>, label=train<sub>y</sub>) dtest = DMatrix(convert(Matrix, deletecols(test, [:EventId])), false, -999.0)</p>
<p>rounds = 3000</p>
<p>param = Dict( &quot;max<sub>depth</sub>&quot; =&gt; 9, &quot;eta&quot; =&gt; 0.01, &quot;sub<sub>sample</sub>&quot; =&gt; 0.9, &quot;objective&quot; =&gt; &quot;binary:logitraw&quot; )</p>
<p>model = xgboost( dtrain, rounds, param=param, metrics=[&quot;ams@0.15&quot;, &quot;auc&quot;] ) ```</p>
<p>### Testing</p>
<p>The kaggle competition expects our submission to be a csv file with the columns EventId, RankOrder, and Class. After calling predict() on the test matrix we created earlier, it will return a vector of logits, or log odds that the item belongs to the signal class.[<sup>9</sup>] By calculating the rank of the logits, we'll take that ordering and map the top 15% to the class 's' and the rest to 'b'.</p>
<p>```julia function rank(xs) ranks = Array{Int64}(undef, length(xs)) order = sortperm(xs)</p>
<p>for i = 1:length(xs) ranks[order[i]] = i end</p>
<p>return ranks end</p>
<p>predictions = predict(model, dtest) rank<sub>order</sub> = rank(predictions) labels = map(x -&gt; x &gt; .85 * size(test, 1) ? 's' : 'b', rank<sub>order</sub>)</p>
<p>submission = DataFrame(EventId=test[:EventId], RankOrder=rank<sub>order</sub>, Class=labels) CSV.write(&quot;submission.csv&quot;, submission) ```</p>
<p>```text Final Score: 3.61149 ```</p>
<p>## Conclusion</p>
<p>I had a lot of fun working on The Higgs Boson Challenge! Particle physics is so overwhelming at first but rewarding when the pieces start to come together. It's so cool to be able to work on and play with the data from one of the greatest achievements in physics in the last century.</p>
<p>Hope you all enjoyed this article! Looking forward to the next one!</p>
<p>[<sup>1</sup>]: <a href="https://en.wikipedia.org/wiki/Higgs_boson" class="uri">https://en.wikipedia.org/wiki/Higgs_boson</a> [<sup>2</sup>]: <a href="http://opendata.cern.ch/record/329" class="uri">http://opendata.cern.ch/record/329</a> [<sup>3</sup>]: <a href="http://opendata.cern.ch/record/328" class="uri">http://opendata.cern.ch/record/328</a> [<sup>4</sup>]: <a href="https://github.com/dmlc/xgboost/blob/master/demo/kaggle-higgs/higgs-cv.py" class="uri">https://github.com/dmlc/xgboost/blob/master/demo/kaggle-higgs/higgs-cv.py</a> [<sup>5</sup>]: <a href="https://www.kaggle.com/c/higgs-boson/overview/evaluation" class="uri">https://www.kaggle.com/c/higgs-boson/overview/evaluation</a> [<sup>6</sup>]: <a href="https://en.wikipedia.org/wiki/ATLAS_experiment" class="uri">https://en.wikipedia.org/wiki/ATLAS_experiment</a> [<sup>7</sup>]: <a href="https://en.wikipedia.org/wiki/Jet_(particle_physics)" class="uri">https://en.wikipedia.org/wiki/Jet_(particle_physics)</a> [<sup>8</sup>]: <a href="http://proceedings.mlr.press/v42/meli14.pdf" class="uri">http://proceedings.mlr.press/v42/meli14.pdf</a> [<sup>9</sup>]: <a href="https://en.wikipedia.org/wiki/Logit" class="uri">https://en.wikipedia.org/wiki/Logit</a></p>
</div></main><footer><div class="wrapper"><div class="column"><h2>Site</h2><a href="/about">About</a><a href="/art">Art</a><a href="/music">Music</a><a href="">Contact</a></div><div class="column"><h2>Links</h2><a href="">Hello</a><a href="">Hello</a></div><div class="column"><h2>Hello World</h2></div></div></footer></div></body></html>